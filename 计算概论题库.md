

# **计算概论题库**

## 基础语法

### 02733:判断闰年

http://cs101.openjudge.cn/2024fallroutine/02733/

**描述**

判断某年是否是闰年。

**输入**

输入只有一行，包含一个整数a(0 < a < 3000)

**输出**

一行，如果公元a年是闰年输出Y，否则输出N

**样例输入**

```python
2006
```

**样例输出**

```python
N
```

```python
a=int(input())
if a%4!=0:
    print("N")
elif a%100==0 and a%400!=0:
        print("N")
elif a%3200==0:
    print("N")
else:print("Y")
```



### 02750: 鸡兔同笼

http://cs101.openjudge.cn/2024fallroutine/02750/

**描述**

一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。

**输入**

一行，一个正整数a (a < 32768)。

**输出**

一行，包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开。
如果没有满足要求的答案，则输出两个0，中间用一个空格分开。

**样例输入**

```
20
```

**样例输出**

```
5 10
```

```python
a=int(input())
if a%2==1:
    print(int(0),int(0))
elif a%4==0:
    b=a/2
    c=a/4
    print(int(c),int(b))
else:
    b=a/2
    c=(a+2)/4
    print(int(c),int(b))
```



### 200B.Drinks

https://codeforces.com/problemset/problem/200/B

Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.

**Input**

The first input line contains a single integer *n* (1 ≤ *n* ≤ 100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0 ≤ *p**i* ≤ 100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.

**Output**

Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10 ** - 4.

**Examples**

**Input**

```
3
50 50 100
```

**Output**

```
66.666666666667
```

**Input**

```
4
0 25 50 75
```

**Output**

```
37.500000000000
```

```python
n=int(input())
p=list(map(int,input().split()))
a=float(sum(p)/n)
print(a)
```



### 1A. Theatre Square

https://codeforces.com/problemset/problem/1/A

Theatre Square in the capital city of Berland has a rectangular shape with the size *n* × *m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a* × *a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.

**Input**

The input contains three positive integer numbers in the first line: *n*,  *m* and *a* (1 ≤  *n*, *m*, *a* ≤ 109).

**Output**

Write the needed number of flagstones.

**Examples**

**Input**

```
6 6 4
```

**Output**

```
4
```

```python
a,b,c=map(int,input().split())
if a%c!=0:
	A=int(a/c)+1
else:
	A=int(a/c)
if b%c!=0:
	B=int(b/c)+1
else:
	B=int(b/c)
print(A*B)
```



### 158A. Next Round

http://codeforces.com/problemset/problem/158/A

"Contestant who earns a score equal to or greater than the *k*-th place finisher's score will advance to the next round, as long as the contestant earns a positive score..." — an excerpt from contest rules.

A total of *n* participants took part in the contest (*n* ≥ *k*), and you already know their scores. Calculate how many participants will advance to the next round.

**Input**

The first line of the input contains two integers *n* and *k* (1 ≤ *k* ≤ *n* ≤ 50) separated by a single space.

The second line contains *n* space-separated integers *a*1, *a*2, ..., *a**n* (0 ≤ *a**i* ≤ 100), where *a**i* is the score earned by the participant who got the *i*-th place. The given sequence is non-increasing (that is, for all *i* from 1 to *n* - 1 the following condition is fulfilled: *a**i* ≥ *a**i* + 1).

**Output**

Output the number of participants who advance to the next round.

**Examples**

**Input**

```
8 5
10 9 8 7 7 7 5 5
```

**Output**

```
6
```

**Input**

```
4 2
0 0 0 0
```

**Output**

```
0
```

```python
a,b=map(int,input().split())
line=input().strip()
parts=line.split()
for i in range(a):
	if i<b and int(parts[i])==0:
		print(i)
		break
	if i>=b and int(parts[i])<int(parts[i-1]):
		print(i)
		break
	if i==a-1 and int(parts[i])==int(parts[i-1]):
		print(a)
	elif i+1==a==b and int(parts[i])!=0:
		print(a)
```



### 266A. Stones on the Table

http://codeforces.com/problemset/problem/266/A

There are *n* stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.

**Input**

The first line contains integer *n* (1 ≤ *n* ≤ 50) — the number of stones on the table.

The next line contains string *s*, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to *n* from left to right. Then the *i*-th character *s* equals "R", if the *i*-th stone is red, "G", if it's green and "B", if it's blue.

**Output**

Print a single integer — the answer to the problem.

**Examples**

**Input**

```
3
RRG
```

**Output**

```
1
```

**Input**

```
5
RRRRR
```

**Output**

```
4
```

```python
a=int(input())
b=str(input())
m=0
for i in range(a-1):
	if b[i]==b[i+1]:
		m+=1
print(m)
```



### 263A. Beautiful Matrix

http://codeforces.com/problemset/problem/263/A

You've got a 5 × 5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:

1. Swap two neighboring matrix rows, that is, rows with indexes *i* and *i* + 1 for some integer *i* (1 ≤ *i* < 5).
2. Swap two neighboring matrix columns, that is, columns with indexes *j* and *j* + 1 for some integer *j* (1 ≤ *j* < 5).

You think that a matrix looks *beautiful*, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.

**Input**

The input consists of five lines, each line contains five integers: the *j*-th integer in the *i*-th line of the input represents the element of the matrix that is located on the intersection of the *i*-th row and the *j*-th column. It is guaranteed that the matrix consists of 24 zeroes and a single number one.

**Output**

Print a single integer — the minimum number of moves needed to make the matrix beautiful.

**Examples**

**Input**

```
0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
```

**Output**

```
3
```

**Input**

```
0 0 0 0 0
0 0 0 0 0
0 1 0 0 0
0 0 0 0 0
0 0 0 0 0
```

**Output**

```
1
```

```python
m=0
for i in range(5):
	a,b,c,d,e=map(int,input().split())
	if a==1 or e==1:
		m+=2
		m+=abs(i-2)
	if b==1 or d==1:
		m+=1
		m+=abs(i-2)
	if c==1:
		m+=abs(i-2)
print(m)
```



### 1328A. Divisibility Problem

https://codeforces.com/problemset/problem/1328/A

You are given two positive integers aa and bb. In one move you can increase aa by 11 (replace aa with a+1a+1). Your task is to find the minimum number of moves you need to do in order to make aa divisible by bb. It is possible, that you have to make 00 moves, as aa is already divisible by bb. You have to answer tt independent test cases.

**Input**

The first line of the input contains one integer tt (1≤t≤1041≤t≤104) — the number of test cases. Then tt test cases follow.

The only line of the test case contains two integers aa and bb (1≤a,b≤1091≤a,b≤109).

**Output**

For each test case print the answer — the minimum number of moves you need to do in order to make aa divisible by bb.

**Example**

**Input**

```
5
10 4
13 9
100 13
123 456
92 46
```

**Output**

```
2
5
4
333
0
```

```python
a=int(input())
list=[]
for i in range(a):
	b,c=map(int,input().split())
	if b%c==0:
		m=0
	else:
		m=c-(b%c)
	list.append(m)
for i in range(len(list)):
	print(list[i])
```



### 12566: 编码字符串

http://cs101.openjudge.cn/2024fallroutine/12556/

**描述**

在数据压缩中，一个常用的方法是行程长度编码压缩。对于一个待压缩的字符串，我们可以依次记录每个字符及重复的次数。例如，待压缩的字符串为"aaabbbbcbb"，压缩结果为(a,3)(b,4)(c,1)(b,2)。这种压缩对于相邻数据重复较多的情况有效，如果重复状况较少，则压缩的效率较低。

现要求根据输入的字符串，首先将字符串中所有大写字母转化为小写字母，然后将字符串进行压缩。

**输入**

一个字符串，长度大于0，且不超过1000，全部由大写或小写字母组成。

**输出**

输出为编码之后的字符串，形式为：(a,3)(b,4)(c,1)(d,2)，即每对括号内分别为小写字符及重复的次数，不含任何空格。

**样例输入**

```
aAABBbBCCCaaaaa
```

**样例输出**

```
(a,3)(b,4)(c,3)(a,5)
```

```python
M=input()
m=str(M)
m=m.lower()
L=len(m)
al=1
list=[]
for i in range(L-1):
    if m[i]==m[i+1]:
        al+=1
    else:
        list.append(f"({m[i]},{al})")
        al=1
if m[-1]==m[L-2]:
    list.append(f"({m[-1]},{al})")
else:
    list.append(f"({m[-1]},{1})")
print("".join(list))
```



### 19949: 提取实体

http://cs101.openjudge.cn/2024fallroutine/19949/

**描述**

一个句子里面一些特殊的单词被称作实体，实体是存在于现实世界中并且可以与其他物体区分开来的物体，如“John has an apple .”这句话中，“John”和“apple”都是实体。

现在我们有很多个人工标注好实体的英文文档，每篇文档有很多个句子，每个句子中，每个实体的每单词都添加了“###”前缀，并且添加了“###”后缀，表明两个“###”之间的部分是实体或者是实体的一部分。例如：

1）两个“###”之间是实体：

“###John### has an ###apple### ”中有两个实体，是John和apple
2）两个“###”之间是实体的一部分，即是，连续的几个被“###”前后包裹的单词被认为是同一个实体：

“###Shelley### ###Berkley### , a Democratic representative”中有一个实体，是Shelley Berkley

“###Dominic### ###J.### ###Baranello### , an enduring power in Democratic Party”中有一个实体，是Dominic J. Baranello

请你帮助统计每篇文档里有多少个实体，暂时不考虑句子间的实体有重复的情况。

**输入**

第一行为1个整数N，代表文档里的句子数目。
接下来N行，每行代表一个英文句子，每个句子有多少单词是未知的，词与词之间用空格分隔。

**输出**

1个整数，代表该篇文档里的实体数目。

**样例**

```
Sample1 Input:
1
###John### has an ###apple### .

Sample1 Output:
2

解释： 文档中只有一个句子，该句子中有两个实体“John”和“apple”，所以输出是2 。
```

```python
a=int(input())
G=0
for i in range(a):
    m=input()
    count=m.count('###')
    b=count/2
    c=m.count('### ###')
    G=G+b-c
print(int(G))
```



### 23564: 数论

http://cs101.openjudge.cn/2024fallroutine/23564

**描述**

M函数在数论中应用广泛，这里记为μ。

无平方数因数的数（square-free integer）是指其因数中，没有一个是平方数的正整数。简言之，将一个这样的数予以质因数分解（即，一个整数写成几个质数的乘积）后，所有质因数的幂都不会大于或等于2。

对于任何正整数n，定义μ(n)的值域为{-1, 0, 1}，μ(n)的值取决于n的质因数分解：

• 如果n是一个具有偶数个质因数，且无平方质因数的正整数，那么μ(n)=1。

• 如果n是一个具有奇数个质因数，且无平方质因数的正整数，那么μ(n)=-1。

• 如果n存在平方质因数，那么μ(n)=0。

例如n=75，存在平方质因数5，75=3*(5^2)，5是75的质因数，且次数为2。

**输入**

一行，一个整数n，保证 n <= 10^6。

**输出**

一行，一个整数 μ(n)

**样例输入**

```
Sample Input1:
12

Sample Output1:
0

解释
n=12=2*2*3，存在平方质因数2，故μ(n)=0。

Sample Input2:
1

Sample Output2:
1

解释
1没有质因数，质因数数量为0，0是偶数，故μ(n)=1。
```

**样例输出**

```
Sample Input3:
25935

Sample Output3:
-1
解释
n=25935=3*5*7*13*19，含有奇数个质因数，且不存在平方质因数，故μ(n)=-1。

Sample Input4:
30013

Sample Output4:
-1
解释
30013 = 30013，有1个质因数，且不存在平方质因数，故μ(n)=-1。
```

```python
def pFactors(n):
    """Finds the prime factors of 'n'"""
    from math import sqrt
    pFact, limit, check, num = [], int(sqrt(n)) + 1, 2, n

    for check in range(2, limit):
        while num % check == 0:
            pFact.append(check)
            num /= check
    if num > 1:
        pFact.append(num)
    return pFact
a=int(input())
L=pFactors(a)
b=len(L)
c=0
for i in range(b-1):
    if L[i]==L[i+1]:
        c+=1
if c>=1:
    print("0")
else:
    if b%2==0:
        print("1")
    else:
        print("-1")
```



### 03143: 验证哥德巴赫猜想

http://cs101.openjudge.cn/2024fallroutine/03143

**描述**

验证“歌德巴赫猜想”，即：任意一个大于等于6的偶数均可表示成两个素数之和。

**输入**

输入只有一个正整数x。(x<=2000)

**输出**

如果x不是“**大于等于**6的偶数”，则输出一行：
Error!
否则输出这个数的**所有**分解形式，形式为：
x=y+z
其中x为待验证的数，y和z满足y+z=x，而且y<=z，y和z均是素数。
如果存在多组分解形式，则按照**y的升序**输出所有的分解，每行一个分解表达式。

注意输出**不要**有多余的空格。

**样例输入**

```
输入样例1:
7
输入样例2:
10
输入样例3:
100
```

**样例输出**

```
输出样例1:
Error!
输出样例2:
10=3+7
10=5+5
输出样例3:
100=3+97
100=11+89
100=17+83
100=29+71
100=41+59
100=47+53
```

```python
a=int(input())
if a<6 or a%2!=0:
    print("Error!")
else:
    for i in range (2,int(a/2)+1):
        b=0
        c=0
        for j in range(2,int(i)):
            if i%j==0:
                b=1
        for k in range(2,int(a-i)):
            if (a-i)%k==0:
                c=1
        if b+c==0:
            print(str(a)+"="+str(i)+"+"+str(a-i))
```



### 19944: 这一天星期几

http://cs101.openjudge.cn/2024fallroutine/19944

**描述**

在日常生活中，计算某一个具体的日期是星期几，往往需要去翻阅日历。请你帮助更快地计算出每个日期在一星期是第几天。

参考：

蔡勒公式（Zeller's congruence），是一种计算任何一日属一星期中哪一日的算法，由德国数学家克里斯提安·蔡勒推算出来，可以计算1582年10月15日之后的情况。

![img](http://media.openjudge.cn/images/upload/1575881738.png)

公式都是基于公历的置闰规则来考虑。

公式中的符号含义如下：

w：星期（计算所得的数值对应的星期：0-Sunday；1-Monday；2-Tuesday；3-Wednesday；4-Thursday；5-Friday；6-Saturday

c：年份前两位数

y：年份后两位数

m：月（**m**的取值范围为3至14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）

d：日

[ ]：称作高斯符号，代表向下取整，即，取不大于原数的最大整数。

mod：同余（这里代表括号里的答案除以7后的余数）

**输入**

第一行1个整数n，代表输入日期的个数。
接下来n行分别为n个以8位数字表示的日期，如20190101
保证所有输入都在蔡勒公式的计算范围之内。

**输出**

共n行，每行为该日期对应的weekday名称（Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday）。

**样例输入**

```
15
19850706
19710710
20041125
20141220
19841128
19760429
19931102
19951002
20161006
20151226
19790715
20080410
20091104
19910621
19891012
```

**样例输出**

```
Saturday
Saturday
Thursday
Saturday
Wednesday
Thursday
Tuesday
Monday
Thursday
Saturday
Sunday
Thursday
Wednesday
Friday
Thursday
```

```python
b=int(input())
list=[]
for i in range(b):
    a=input()
    A=str(a)
    c=int(A[:2])
    d=int(A[6:8])
    if int(A[4:6])>=3:
        y=int(A[2:4])
        m=int(A[4:6])
    else:
        y=int(A[2:4])-1
        m=int(A[4:6])+12
    if int(A[4:6])<=2 and int(A[2:4])==0:
        c=int(A[:2])-1
        y=99
        m=int(A[4:6])+12
    G=y+int(y/4)+int(c/4)-2*c+int(26*(m+1)/10)+d-1
    w=G%7
    if w==1:
        list.append('Monday')
    if w==2:
        list.append('Tuesday')
    if w==3:
        list.append('Wednesday')
    if w==4:
        list.append('Thursday')
    if w==5:
        list.append('Friday')
    if w==6:
        list.append('Saturday')
    if w==0:
        list.append('Sunday')
for i in list:
    print(i)
```



### 03248: 最大公约数

http://cs101.openjudge.cn/2024fallroutine/03248

**描述**

给定两个正整数，求它们的最大公约数。

**输入**

有多组数据，每行为两个正整数，且不超过int可以表示的范围。

**输出**

行对应输出最大公约数。

**样例输入**

```
4 8
8 6
200 300
```

**样例输出**

```
4
2
100
```

```python
try:
    while True:
        a,b=map(int,input().split())
        while b!=0:
            a,b=b,a%b
        else:
            print(a)
except EOFError:
    pass
```



### 282A. Bit++

https://codeforces.com/problemset/problem/282/A

The classic programming language of Bitland is Bit++. This language is so peculiar and complicated.

The language is that peculiar as it has exactly one variable, called *x*. Also, there are two operations:

- Operation ++ increases the value of variable *x* by 1.
- Operation -- decreases the value of variable *x* by 1.

A statement in language Bit++ is a sequence, consisting of exactly one operation and one variable *x*. The statement is written without spaces, that is, it can only contain characters "+", "-", "X". Executing a statement means applying the operation it contains.

A programme in Bit++ is a sequence of statements, each of them needs to be executed. Executing a programme means executing all the statements it contains.

You're given a programme in language Bit++. The initial value of *x* is 0. Execute the programme and find its final value (the value of the variable when this programme is executed).

**Input**

The first line contains a single integer *n* (1 ≤ *n* ≤ 150) — the number of statements in the programme.

Next *n* lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable *x* (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.

**Output**

Print a single integer — the final value of *x*.

**Examples**

**Input**

```
1
++X
```

**Output**

```
1
```

**Input**

```
2
X++
--X
```

**Output**

```
0
```

```python
n=int(input())
m=0
for i in range(n):
    a=input()
    if a=="X++" or a=="++X":
        m=m+1
    else:
        m=m-1
print(m)         
```



### 705A. Hulk

https://codeforces.com/contest/705/problem/A

Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.

Hulk likes the Inception so much, and like that his feelings are complicated. They have *n* layers. The first layer is hate, second one is love, third one is hate and so on...

For example if *n* = 1, then his feeling is "I hate it" or if *n* = 2 it's "I hate that I love it", and if *n* = 3 it's "I hate that I love that I hate it" and so on.

Please help Dr. Banner.

**Input**

The only line of the input contains a single integer *n* (1 ≤ *n* ≤ 100) — the number of layers of love and hate.

**Output**

Print Dr.Banner's feeling in one line.

**Examples**

**Input**

```
1
```

**Output**

```
I hate it
```

**Input**

```
2
```

**Output**

```
I hate that I love it
```

**Input**

```
3
```

**Output**

```
I hate that I love that I hate it
```

```python
a=int(input())
list=[]
if a%2!=0:
	for i in range(a,1,-1):
		if i%2!=0:
			list.append("I hate that")
		else:
			list.append("I love that")
	list.append("I hate it")
	output=" ".join(list)
else:
	for i in range(a,1,-1):
		if i%2!=0:
			list.append("I love that")
		else:
			list.append("I hate that")
	list.append("I love it")
	output=" ".join(list)
print(output)
```



### 615A. Bulbs

https://codeforces.com/problemset/problem/615/A

Vasya wants to turn on Christmas lights consisting of *m* bulbs. Initially, all bulbs are turned off. There are *n* buttons, each of them is connected to some set of bulbs. Vasya can press any of these buttons. When the button is pressed, it turns on all the bulbs it's connected to. Can Vasya light up all the bulbs?

If Vasya presses the button such that some bulbs connected to it are already turned on, they do not change their state, i.e. remain turned on.

**Input**

The first line of the input contains integers *n* and *m* (1 ≤ *n*, *m* ≤ 100) — the number of buttons and the number of bulbs respectively.

Each of the next *n* lines contains *x**i* (0 ≤ *x**i* ≤ *m*) — the number of bulbs that are turned on by the *i*-th button, and then *x**i* numbers *y**ij* (1 ≤ *y**ij* ≤ *m*) — the numbers of these bulbs.

**Output**

If it's possible to turn on all *m* bulbs print "YES", otherwise print "NO".

**Examples**

**Input**

```
3 4
2 1 4
3 1 3 1
1 2
```

**Output**

```
YES
```

**Input**

```
3 3
1 1
1 2
1 1
```

**Output**

```
NO
```

```python
a,b=map(int,input().split())
s=set()
for i in range(a):
	line=input().strip()
	parts=line.split()
	numbers=tuple(map(int,parts[1:]))
	for x in numbers:
		s.add(x)
if len(s)==b:
	print("YES")
else:
	print("NO")
 
```



### 723A. The New Year: Meeting Friends

https://codeforces.com/contest/723/problem/A

There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.

**Input**

The first line of the input contains three **distinct** integers *x*1, *x*2 and *x*3 (1 ≤ *x*1, *x*2, *x*3 ≤ 100) — the coordinates of the houses of the first, the second and the third friends respectively.

**Output**

Print one integer — the minimum total distance the friends need to travel in order to meet together.

**Examples**

**Input**

```
7 1 4
```

**Output**

```
6
```

**Input**

```
30 20 10
```

**Output**

```
20
```

```python
a,b,c=map(int,input().split())
if a==b or b==c or c==a:
	d=int((abs(a-b)+abs(b-c)+abs(c-a))/2)
	print(d)
else:
	if a<b<c or c<b<a:
		d=abs(c-a)
		print(d)
	if b<a<c or c<a<b:
		d=abs(b-c)
		print(d)
	if a<c<b or b<c<a:
		d=abs(a-b)
		print(d)
```



### 02689: 大小写字母互换

http://cs101.openjudge.cn/2024fallroutine/02689

**描述**

把一个字符串中所有出现的大写字母都替换成小写字母，同时把小写字母替换成大写字母。

**输入**

输入一行：待互换的字符串。

**输出**

输出一行：完成互换的字符串（字符串长度小于80）。

**样例输入**

```
If so, you already have a Google Account. You can sign in on the right. 
```

**样例输出**

```
iF SO, YOU ALREADY HAVE A gOOGLE aCCOUNT. yOU CAN SIGN IN ON THE RIGHT. 
```

```python
a=input()
b=a.swapcase()
print(b)
```



### 118A. String Task

https://codeforces.com/contest/118/problem/A

Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it:

- deletes all the vowels,
- inserts a character "." before each consonant,
- replaces all uppercase consonants with corresponding lowercase ones.

Vowels are letters "A", "O", "Y", "E", "U", "I", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.

**Input**

The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.

**Output**

Print the resulting string. It is guaranteed that this string is not empty.

**Examples**

**Input**

```
tour
```

**Output**

```
.t.r
```

**Input**

```
Codeforces
```

**Output**

```
.c.d.f.r.c.s
```

**Input**

```
aBAcAba
```

**Output**

```
.b.c.b
```

```python
a=input()
b=a.lower()
list=[x for x in b if x.isalpha()]
try:
	while True:
		list.remove("a")
except:
	pass
try:
	while True:
		list.remove("e")
except:
	pass
try:
	while True:
		list.remove("y")
except:
	pass
try:
	while True:
		list.remove("u")
except:
	pass
try:
	while True:
		list.remove("i")
except:
	pass
try:
	while True:
		list.remove("o")
except:
	pass
if len(list)>0:
	out=".".join(list)
	list1=[".",out]
	output="".join(list1)
	print(output)
```



### 18161: 矩阵运算

http://cs101.openjudge.cn/2024fallroutine/18161

**描述**

现有三个矩阵A, B, C，要求矩阵运算A·B+C并输出结果

矩阵运算介绍：
矩阵乘法运算必须要前一个矩阵的列数与后一个矩阵的行数相同，
如m行n列的矩阵A与n行p列的矩阵B相乘，可以得到m行p列的矩阵C，
矩阵C的每个元素都由A的对应行中的元素与B的对应列中的元素一一相乘并求和得到，
即C[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + …… +A[i][n-1]*B[n-1][j]

(C[i][j]表示C矩阵中第i行第j列元素)。

矩阵的加法必须在两个矩阵行数列数均相等的情况下进行，
如m行n列的矩阵A与m行n列的矩阵B相加，可以得到m行n列的矩阵C，
矩阵C的每个元素都由A与B对应位置的元素相加得到，
即C[i][j] = A[i][j] + B[i][j]

**输入**

输入分为三部分，分别是A,B,C三个矩阵的内容。
每一部分的第一行为两个整数，代表矩阵的行数row和列数col
接下来row行，每行有col个整数，代表该矩阵这一行的每个元素

**输出**

如果可以完成矩阵计算，输出计算结果，与输入格式类似，不需要输出行数和列数信息。
如果不能完成矩阵计算，输出"Error!"

**样例输入**

```
Sample Input1:
3 1
0
1
0
1 2
1 1
3 2
3 1
3 1
3 1

Sample Output1:
3 1
4 2
3 1
```

**样例输出**

```
Sample Input2:
1 1
0
2 1
1
3
1 1
9

Sample Output2:
Error!
```

```python
A=[]
B=[]
C=[]
listY=[]
m1,n1=map(int,input().split())
for i in range(m1):
    A1=list(map(int,input().split()))
    A.append(A1)
m2,n2=map(int,input().split())
for i in range(m2):
    B1=list(map(int,input().split()))
    B.append(B1)
m3,n3=map(int,input().split())
for i in range(m3):
    C1=list(map(int,input().split()))
    C.append(C1)
if n1!=m2 or m1!=m3 or n2!=n3:
    print("Error!")
else:
    for i in range(m1):
        listX=[]
        for j in range(n2):
            x=0
            for k in range(n1):
                x+=A[i][k]*B[k][j]
            x+=C[i][j]
            x=str(x)
            listX.append(x)
        listY.append(listX)
    for m in range(m1):
        output= " ".join(listY[m])
        print(output)
```



### 270A. Fancy Fence

https://codeforces.com/contest/270/problem/A

Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?

**Input**

The first line of input contains an integer *t* (0 < *t* < 180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0 < *a* < 180) — the angle the robot can make corners at measured in degrees.

**Output**

For each test, output on a single line "YES" (without quotes), if the robot can build a fence Emuskald wants, and "NO" (without quotes), if it is impossible.

**Examples**

**Input**

```
3
30
60
90
```

**Output**

```
NO
YES
YES
```

```python
a=int(input())
list=[]
for i in range(a):
	b=int(input())
	if b==179:
		list.append("YES")
	else:
		for j in range(1,181):
			if 180*j==b*(j+2):
				list.append("YES")
				break
			elif j==180:
				list.append("NO")
for k in range(a):
	print(list[k])
```



## greedy

### 50A. Domino piling

http://codeforces.com/problemset/problem/50/A

You are given a rectangular board of *M* × *N* squares. Also you are given an unlimited number of standard domino pieces of 2 × 1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.
2. No two dominoes overlap.
3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.

**Input**

In a single line you are given two integers *M* and *N* — board sizes in squares (1 ≤ *M* ≤ *N* ≤ 16).

**Output**

Output one number — the maximal number of dominoes, which can be placed.

**Examples**

**Input**

```
2 4
```

**Output**

```
4
```

**Input**

```
3 3
```

**Output**

```
4
```

```python
x,y=map(int,input().split())
if x//2 or y//2:
	a=int(x*y/2)
else:
	a=int((x*y-1)/2)
print(a)
```



### 231A. Team

http://codeforces.com/problemset/problem/231/A

One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.

**Input**

The first input line contains a single integer *n* (1 ≤ *n* ≤ 1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.

**Output**

Print a single integer — the number of problems the friends will implement on the contest.

**Examples**

**Input**

```
3
1 1 0
1 1 1
1 0 0
```

**Output**

```
2
```

**Input**

```
2
1 0 0
0 1 1
```

**Output**

```
1
```

```python
a=int(input())
m=0
for i in range(a):
	b,c,d=map(int,input().split())
	if b+c+d>=2:
		m=m+1
print(m)
```



### 996A. Hit the Lottery

https://codeforces.com/problemset/problem/996/A

Allen has a LOT of money. He has nn dollars in the bank. For security reasons, he wants to withdraw it in cash (we will not disclose the reasons here). The denominations for dollar bills are 11, 55, 1010, 2020, 100100. What is the minimum number of bills Allen could receive after withdrawing his entire balance?

**Input**

The first and only line of input contains a single integer nn (1≤n≤1091≤n≤109).

**Output**

Output the minimum number of bills that Allen could receive.

**Examples**

**Input**

```
125
```

**Output**

```
3
```

**Input**

```
43
```

**Output**

```
5
```

```python
a=int(input())
b=int(a/100)
a1=a%100
c=int(a1/20)
a2=a1%20
d=int(a2/10)
a3=a2%10
e=int(a3/5)
a4=a3%5
m=b+c+d+e+a4
print(m)
```



### 34B. Sale

https://codeforces.com/problemset/problem/34/B

Once Bob got to a sale of old TV sets. There were *n* TV sets at that sale. TV set with index *i* costs *a**i* bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most *m* TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.

**Input**

The first line contains two space-separated integers *n* and *m* (1 ≤ *m* ≤ *n* ≤ 100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains *n* space-separated integers *a**i* ( - 1000 ≤ *a**i* ≤ 1000) — prices of the TV sets.

**Output**

Output the only number — the maximum sum of money that Bob can earn, given that he can carry at most *m* TV sets.

**Examples**

**Input**

```
5 3
-6 0 35 -2 4
```

**Output**

```
8
```

**Input**

```
4 2
7 0 0 -7
```

**Output**

```
7
```

```python
n,m=map(int,input().split())
list1=sorted(map(int,input().split()))
x=0
for i in range(m):
	if list1[i]<0:
		x-=list1[i]
	else:
		break
print(x)
```



### 160A. Twins

https://codeforces.com/problemset/problem/160/A

Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.

Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, *n* coins of arbitrary values *a*1, *a*2, ..., *a**n*. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.

As you woke up, you found Mom's coins and read her note. "But why split the money equally?" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is **strictly larger** than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the **minimum number of coins**, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what **minimum** number of coins you need to take to divide them in the described manner.

**Input**

The first line contains integer *n* (1 ≤ *n* ≤ 100) — the number of coins. The second line contains a sequence of *n* integers *a*1, *a*2, ..., *a**n* (1 ≤ *a**i* ≤ 100) — the coins' values. All numbers are separated with spaces.

**Output**

In the single line print the single number — the minimum needed number of coins.

**Examples**

**Input**

```
2
3 3
```

**Output**

```
2
```

**Input**

```
3
2 1 2
```

**Output**

```
2
```

```python
n=int(input())
list1=list(map(int,input().split()))
list1.sort(reverse=True)
m=0
for i in range(n):
	m+=list1[i]
x=0
for j in range(n):
	x+=list1[j]
	if x>m/2:
		print(j+1)
		break
```



### 1879B. Chips on the Board

https://codeforces.com/contest/1879/problem/B

You are given a board of size n×n (n rows and n colums) and two arrays of positive integers a and b of size n.

Your task is to place the chips on this board so that the following condition is satisfied for every cell (i,j):

- there exists at least one chip in the same column or in the same row as the cell (i,j). I. e. there exists a cell (x,y) such that there is a chip in that cell, and either x=i or y=j (or both).

The cost of putting a chip in the cell (i,j) is equal to ai+bj.

For example, for n=3, a=[1,4,1] and b=[3,2,2]. One of the possible chip placements is as follows:

![img](https://espresso.codeforces.com/8a130a6b956ff701aa311cef4c7bff39670a0ddd.png)White squares are empty

The total cost of that placement is (1+3)+(1+2)+(1+2)=10.

Calculate the minimum possible total cost of putting chips according to the rules above.

**Input**

The first line contains a single integer t (1≤t≤104) — the number of test cases.

The first line of each test case contains a single integer n (1≤n≤3⋅105).

The second line contains n integers a1,a2,…,an (1≤ai≤109).

The third line contains n integers b1,b2,…,bn(1≤bi≤109).

The sum of n over all test cases doesn't exceed 3⋅105.

**Output**

For each test case, print a single integer — the minimum possible total cost of putting chips according to the rules.

**Example**

**Input**

```
4
3
1 4 1
3 2 2
1
4
5
2
4 5
2 3
5
5 2 4 5 3
3 4 2 1 5
```

**Output**

```
10
9
13
24
```

```python
n=int(input())
for f in range(n):
	m=int(input())
	list1=sorted(map(int,input().split()))
	list2=sorted(map(int,input().split()))
	x=0
	y=0
	for i in range(m):
		x+=list1[i]
		y+=list2[i]
	print(min(x+m*min(list2),y+m*min(list1)))
```



### 21532: 数学密码

http://cs101.openjudge.cn/2024fallroutine/21532/

**描述**

小明和同学一起去玩密室逃脱，这个密室的老板特别喜欢数学，所以他设置了一个密码门。在搜集了房间里的有价值信息后，小明总结出的信息为：三个互不相同的正整数和为231，那么这三个互不相同正整数的最大公因数就是密码。小明很快的算出了密码。

回到学校后，小明希望写一个程序，对于给定的三个互不相同的正整数的和，快速求出这三个正整数的最大公因数。

**输入**

输入为三个互不相同的正整数的和 (6 ≤ N ≤ 109).

**输出**

输出三个数的最大公因数.

**样例输入**

```
sample1 in:
231

sample1 out:
33
```

**样例输出**

```
sample2 in:
1234

sample2 out:
2

sample3 in:
88

sample3 out:
11
```

```python
a=int(input())
b=6
if a%b==0:
    print(int(a/b))
while a%b!=0:
    b+=1
    if a%b==0:
        print(int(a/b))
        break
```



### 58A. Chat room

https://codeforces.com/problemset/problem/58/A

Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word "hello". For example, if Vasya types the word "ahhellllloou", it will be considered that he said hello, and if he types "hlelo", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.

**Input**

The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.

**Output**

If Vasya managed to say hello, print "YES", otherwise print "NO".

**Examples**

**Input**

```
ahhellllloou
```

**Output**

```
YES
```

**Input**

```
hlelo
```

**Output**

```
NO
```

```python
def function(lst,i,char):
	if lst[i]==char:
		return 1
	else:
		return 0
	pass
a=0
s=input()
list=list(s)
l=len(list)
for i in range(l):
	j1=i
	A=function(list, i, 'h')
	if A==1:
		a=a+1
		break
j2=j1
for i in range(j1+1,l):
	j2=i
	A=function(list, i, 'e')
	if A==1:
		a=a+1
		break
j3=j2
for i in range(j2+1,l):
	j3=i
	A=function(list, i,'l')
	if A==1:
		a=a+1
		break
j4=j3
for i in range(j3+1,l):
	j4=i
	A=function(list, i, 'l')
	if A==1:
		a=a+1
		break
for i in range(j4+1,l):
	A=function(list, i,'o')
	if A==1:
		a=a+1
		break
if a==5:
	print("YES")
else:
	print("NO")
```



### 339A. Helpful Maths

https://codeforces.com/contest/339/problem/A

Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.

The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.

You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.

**Input**

The first line contains a non-empty string *s* — the sum Xenia needs to count. String *s* contains no spaces. It only contains digits and characters "+". Besides, string *s* is a correct sum of numbers 1, 2 and 3. String *s* is at most 100 characters long.

**Output**

Print the new sum that Xenia can count.

**Examples**

**Input**

```
3+2+1
```

**Output**

```
1+2+3
```

**Input**

```
1+1+3+1+3
```

**Output**

```
1+1+1+3+3
```

```python
list1=[]
my_list = []
a = input()
b = str(a)
B = len(b)
for i in range(0, B, 2):
    G = b[i]
    list1.append(G)
 
c = list1.count('1')
d = list1.count('2')
e = list1.count('3')
 
for i in range(c-1):
    my_list.append("1")
    my_list.append("+")
if e==0 and d==0 and c!=0:
    my_list.append("1")
if d+e!=0 and c!=0:
    my_list.append("1")
    my_list.append("+")
for i in range(d-1):
    my_list.append("2")
    my_list.append("+")
if e == 0 and d!=0:
    my_list.append("2")
if e!=0 and d!=0:
    my_list.append("2")
    my_list.append("+")
for i in range(e - 1):
    my_list.append("3")
    my_list.append("+")
if e != 0:
    my_list.append("3")
 
output = "".join(my_list)
print(output)
```





## brute force

### 4A. Watermelong

http://codeforces.com/problemset/problem/4/A

One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.

**Input**

The first (and the only) input line contains integer number *w* (1 ≤ *w* ≤ 100) — the weight of the watermelon bought by the boys.

**Output**

Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.

**Examples**

**Input**

```
8
```

**Output**

```
YES
```

```python
a=int(input())
if a%2==1 or a<3:
	print("NO")
else:
	print("YES")
```



### 236A. Boy or Girl

https://codeforces.com/problemset/problem/236/A

Those days, many boys use beautiful girls' photos as avatars in forums. So it is pretty hard to tell the gender of a user at the first glance. Last year, our hero went to a forum and had a nice chat with a beauty (he thought so). After that they talked very often and eventually they became a couple in the network.

But yesterday, he came to see "her" in the real world and found out "she" is actually a very strong man! Our hero is very sad and he is too tired to love again now. So he came up with a way to recognize users' genders by their user names.

This is his method: if the number of distinct characters in one's user name is odd, then he is a male, otherwise she is a female. You are given the string that denotes the user name, please help our hero to determine the gender of this user by his method.

**Input**

The first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.

**Output**

If it is a female by our hero's method, print "CHAT WITH HER!" (without the quotes), otherwise, print "IGNORE HIM!" (without the quotes).

**Examples**

**Input**

```
wjmzbmr
```

**Output**

```
CHAT WITH HER!
```

**Input**

```
xiaodao
```

**Output**

```
IGNORE HIM!
```

```python
a=input()
a=str(a)
list1=[]
for i in a:
	list1.append(i)
set1=set(list1)
l=len(set1)
if l%2==1:
	print("IGNORE HIM!")
else:
	print("CHAT WITH HER!")
```



### 18223: 24点

http://cs101.openjudge.cn/2024fallroutine/18223/

**描述**

给定4个整数，判断是否能只用加减运算（即在4个数中间插入3个+或-符号，可以调换数字顺序），使得运算结果为24。

**输入**

第一行1个整数，代表m组数据（1≤m≤100）
接下来m行，每行为4个整数， Xi (1≤Xi≤10^100)，注意整数可能很大。

**输出**

共m行，每行为YES或者NO，代表是否能凑成24点。
对于如下输入，6+6+6+6=24,25-3+1+1=24，100000000000000000000000-100000000000000000000000-100000000000000000000000+100000000000000000000024=24

**样例输入**

```
4
6 6 6 6
3 25 1 1
100000000000000000000000 100000000000000000000000 100000000000000000000000 100000000000000000000024
2 3 4 5
```

**样例输出**

```
YES
YES
YES
NO
```

```python
M=int(input())
for i in range(M):
    a,b,c,d=map(int,input().split())
    if abs(a+b+c+d)==24 or abs(a+b+c-d)==24 or abs(a+b-c+d)==24 or abs(a+b-c-d)==24  or abs(a-b+c+d)==24 or abs(a-b+c-d)==24 or abs(a-b-c+d)==24 or abs(a-b-c-d)==24:
        print("YES")
    else:
        print("NO")
```



### 01003: Hangover

http://cs101.openjudge.cn/2024fallroutine/01003/

**描述**

How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We're assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 `+` 1/3 `=` 5/6 card lengths. In general you can make *n* cards overhang by 1/2 `+` 1/3 `+` 1/4 `+` ... `+` 1/(*n* `+` 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(*n* `+` 1). This is illustrated in the figure below.

![img](http://media.openjudge.cn/images/1003/hangover.jpg)

**输入**

The input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits.

**输出**

For each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples.

**样例输入**

```
1.00
3.71
0.04
5.19
0.00
```

**样例输出**

```
3 card(s)
61 card(s)
1 card(s)
273 card(s)
```

```python
while True:
    b=float(input())
    if b==0.00:
        break
    c=0
    for j in range(2,500):
        c=float(1/j)+c
        if c>=b:
            print(j-1,"card(s)")
            break
```



### 580A. Kefa and First Step

https://codeforces.com/problemset/problem/580/A

Kefa decided to make some money doing business on the Internet for exactly *n* days. He knows that on the *i*-th day (1 ≤ *i* ≤ *n*) he makes *a**i* money. Kefa loves progress, that's why he wants to know the length of the maximum non-decreasing subsegment in sequence *a**i*. Let us remind you that the subsegment of the sequence is its continuous fragment. A subsegment of numbers is called non-decreasing if all numbers in it follow in the non-decreasing order.

Help Kefa cope with this task!

**Input**

The first line contains integer *n* (1 ≤ *n* ≤ 105).

The second line contains *n* integers *a*1,  *a*2,  ...,  *a**n* (1 ≤ *a**i* ≤ 109).

**Output**

Print a single integer — the length of the maximum non-decreasing subsegment of sequence *a*.

**Examples**

**Input**

```
6
2 2 1 3 4 1
```

**Output**

```
3
```

**Input**

```
3
2 2 9
```

**Output**

```
3
```

```python
a=int(input())
n=list(map(int, input().strip().split()))
m=1
M=1
if a==1:
	M=1
else:
	for i in range(a-1):
		if int(n[i])<=int(n[i+1]):
			m=m+1
			if M<=m:
				M=m
		else:
			m=1
print(M)
```





## bucket

### 02808: 校门外的树

http://cs101.openjudge.cn/2024fallroutine/02808/

**描述**

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。
马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

**输入**

输入的第一行有两个整数L（1 <= L <= 10000）和 M（1 <= M <= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。

**输出**

输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。

**样例输入**

```
500 3
150 300
100 200
470 471
```

**样例输出**

```
298
```

```python
a,b=map(int,input().split())
initial_list=list(range(a+1))
remove_set=set()
for i in range(b):
    c,d=map(int,input().split())
    for j in range(c,d+1):
        remove_set.add(j)
remaining_list=[x for x in initial_list if x not in remove_set]
print(len(remaining_list))
```

